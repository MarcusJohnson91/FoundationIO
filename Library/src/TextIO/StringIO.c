#include "../include/StringIO.h"
#include "../include/BitIOLog.h"

#if    (BitIOTargetOS == BitIOWindowsOS)
#pragma warning(push, 0)
#endif
#include <stdlib.h>  /* Included for calloc, and free */
#if    (BitIOTargetOS == BitIOWindowsOS)
#pragma warning(pop)
#endif

#define UnicodeNULLTerminatorSize       1
#define UnicodeBOMSize                  1
#define WhitespaceTableSize            30
#define NormalizationTableIndex        45
#define NormalizationTableNumDiacritics 1
#define NormalizationTableBaseCodePoint 1
#define NormalizationTableDiacritics    1
//#define NormalizationTablePrecomposed   1

//#define NormalizationTableNumDiacritics 2
//#define NormalizationTableMaxWidth      5
#define SimpleCaseFoldTableSize      1298

/* 0x00 is valid in UTF-16, NULL is 0x0000, be sure to catch this mistake. */
/* U+D800 - U+DFFF are invalid UTF32 code points. when converting to/from UTF32 make sure that that is not a code point becuse they're reserved as UTF-16 surrogate pairs */
/* UTF-16 High/Low Surrogate mask = 0xFC00 */

#ifdef  __cplusplus
extern  "C" {
#endif
    
    static UTF8Constant StringIOLibraryName = u8"libBitIO_StringIO";
    
    static uint8_t      UTF8String_GetCodePointSize(uint8_t CodeUnit) {
        uint8_t CodePointSize      = 0;
        if (((CodeUnit & 0x80) >> 7) == 0) {
            CodePointSize         += 1;
        } else if (((CodeUnit & 0xE0) >> 5) == 6) {
            CodePointSize         += 2;
        } else if (((CodeUnit & 0xF0) >> 4) == 14) {
            CodePointSize         += 3;
        } else if (((CodeUnit & 0xF8) >> 3) == 30) {
            CodePointSize         += 4;
        }
        return CodePointSize;
    }
    
    uint64_t            UTF8String_GetNumCodeUnits(UTF8String String2Count) { // Read a codeunit, get it's size, skip that many bytes, check that it's not 0x0, then repeat
        uint64_t NumCodeUnits                       = 0ULL;
        uint64_t CurrentCodeUnit                    = 0ULL;
        if (String2Count != NULL) {
            do {
                NumCodeUnits                       += UTF8String_GetCodePointSize(String2Count[CurrentCodeUnit]);
            } while (String2Count[CurrentCodeUnit] != 0);
        } else {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL");
        }
        return NumCodeUnits;
    }
    
    uint64_t            UTF8String_GetNumCodePoints(UTF8String String) {
        uint64_t CurrentCodeUnit              = 0ULL;
        uint64_t NumCodePoints                = 0ULL;
        if (String != NULL) {
            do {
                CurrentCodeUnit              += UTF8String_GetCodePointSize(String[CurrentCodeUnit]);
                NumCodePoints                += 1;
            } while (String[CurrentCodeUnit] != 0);
        } else {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL");
        }
        return NumCodePoints;
    }
    
    uint8_t             UTF16String_GetCodePointSize(uint16_t CodeUnit) {
        uint8_t CodePointSize = 0;
        if (CodeUnit >= 0xD800 && CodeUnit <= 0xDFFF) { // Surrogate
            CodePointSize     = 2;
        } else {
            CodePointSize     = 1;
        }
        return CodePointSize;
    }
    
    uint64_t            UTF16String_GetNumCodeUnits(UTF16String String) {
        uint64_t NumCodeUnits       = 0ULL;
        uint64_t CodePoint          = 0ULL;
        do {
            NumCodeUnits += UTF16String_GetCodePointSize(String[CodePoint]);
            CodePoint    += 1;
        } while (String[CodePoint] != 0);
        return NumCodeUnits;
    }
    
    uint64_t            UTF16String_GetNumCodePoints(UTF16String String) {
        uint64_t NumCodeUnits           = 0ULL;
        uint64_t NumCodePoints          = 0ULL;
        do {
            NumCodeUnits               += UTF16String_GetCodePointSize(String[NumCodeUnits]);
            NumCodePoints              += 1;
        } while (String[NumCodePoints] != 0);
        return NumCodePoints;
    }
    
    static uint64_t     UTF32String_GetNumCodeUnits4UTF8(UTF32String String) {
        uint64_t CodePoint          = 0ULL;
        uint64_t UTF8CodeUnits      = 0ULL;
        do {
            if (String[CodePoint] <= 0x7F) {
                UTF8CodeUnits      += 1;
            } else if (String[CodePoint] >= 0x80 && String[CodePoint] <= 0x7FF) {
                UTF8CodeUnits      += 2;
            } else if (String[CodePoint] >= 0x800 && String[CodePoint] <= 0xFFFF) {
                UTF8CodeUnits      += 3;
            } else if (String[CodePoint] >= 0x10000 && String[CodePoint] <= 0x1FFFFF) {
                UTF8CodeUnits      += 4;
            }
            CodePoint              += 1;
        } while (String[CodePoint] != 0);
        return UTF8CodeUnits;
    }
    
    static uint64_t     UTF32String_GetNumCodeUnits4UTF16(UTF32String String) {
        uint64_t CodePoint          = 0ULL;
        uint64_t UTF16CodeUnits     = 0ULL;
        do {
            if (String[CodePoint] >= 0x10000) {
                UTF16CodeUnits     += 2;
            } else {
                UTF16CodeUnits     += 1;
            }
            CodePoint              += 1;
        } while (String[CodePoint] != 0);
        return UTF16CodeUnits;
    }
    
    /* Decode UTF-X to UTF-32 */
    UTF32String         UTF8String_Decode(UTF8String String) {
        // We should make sure we don't decode anything in the surrogate block, between 0xDBFF to 0xD800 or DFFF to DC00
        uint8_t  CodePointSize      = 0;
        uint64_t CodeUnitNum        = 0ULL;
        uint64_t CodePoint          = 0ULL;
        UTF32String DecodedString   = NULL;
        if (String != NULL) {
            uint64_t UTF8CodePoints = UTF8String_GetNumCodePoints(String) + UnicodeNULLTerminatorSize + UnicodeBOMSize;
            DecodedString           = calloc(UTF8CodePoints, sizeof(UTF32String));
            if (DecodedString != NULL) {
                do {
                    // Get the number of codepoints contained in the UTF8String, then allocate that much memory, then decode.
                    if (CodePoint == 0) {
                        // set the Unicode BOM
#if   (RuntimeByteOrder == LSByte)
                        DecodedString[0] = 0xFFFE;
#elif (RuntimeByteOrder == MSByte)
                        DecodedString[0] = 0xFEFF;
#endif
                    }
                    switch (CodePointSize) {
                        case 1: // 7 bits
                            DecodedString[CodePoint] =  String[CodeUnitNum - 1];
                            CodeUnitNum             += 1;
                            break;
                        case 2: // 11 bits, U+80 - U+7FF
                            DecodedString[CodePoint] = (String[CodeUnitNum - 1] & 0x1F) << 6;
                            DecodedString[CodePoint] =  String[CodeUnitNum]     & 0x3F;
                            CodeUnitNum             += 2;
                            break;
                        case 3: // 16 bits, U+800 - U+FFFF (except U+D800 - U+DFFF)
                            DecodedString[CodePoint] = (String[CodeUnitNum - 1] & 0x0F) << 12;
                            DecodedString[CodePoint] = (String[CodeUnitNum]     & 0x1F) << 6;
                            DecodedString[CodePoint] = (String[CodeUnitNum + 1] & 0x1F);
                            CodeUnitNum             += 3;
                            break;
                        case 4: // 21 bits, U+10000 - U+10FFFF
                            DecodedString[CodePoint] = (String[CodeUnitNum - 1] & 0x07) << 18;
                            DecodedString[CodePoint] = (String[CodeUnitNum]     & 0x3F) << 12;
                            DecodedString[CodePoint] = (String[CodeUnitNum + 1] & 0x3F) <<  6;
                            DecodedString[CodePoint] = (String[CodeUnitNum + 2] & 0x3F);
                            CodeUnitNum             += 4;
                            break;
                    }
                    if (DecodedString[CodePoint]    <= 0x7F && CodePointSize > 1) { // Invalid, overlong sequence detected, replace it with 0xFFFD
                        DecodedString[CodePoint]     = 0xFFFD;
                        BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"CodePoint %d is overlong, replaced with U+FFFD", CodePoint);
                    } else if ((DecodedString[CodePoint] >= 0xD800 && DecodedString[CodePoint] <= 0xDBFF) || (DecodedString[CodePoint] >= 0xDC00 && DecodedString[CodePoint] <= 0xDFFF)) {
                        DecodedString[CodePoint]     = 0xFFFD;
                        BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, "Codepoint %d is invalid, overlaps Surrogate Pair Block, replacing with U+FFFD", CodePoint);
                    }
                } while (String[CodeUnitNum] != 0);
            } else {
                BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"Not enough memory to allocate string");
            }
        } else {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL");
        }
        return DecodedString;
    }
    
    UTF8String          UTF8String_Encode(UTF32String String) {
        uint64_t CodePoint                             = 0ULL;
        uint64_t CodeUnitNum                           = 0ULL;
        UTF8String EncodedString                       = NULL;
        if (String != NULL) {
            uint64_t UTF8CodeUnits                     = UTF32String_GetNumCodeUnits4UTF8(String) + UnicodeNULLTerminatorSize;
            EncodedString                              = calloc(UTF8CodeUnits, sizeof(UTF8String));
            if (EncodedString != NULL) {
                do {
                    if (String[CodePoint] >= 0xD800 && String[CodePoint] <= 0xDFFF) {
                        String[CodePoint]              = 0xFFFD;
                        BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, "Codepoint %d is invalid, overlaps Surrogate Pair Block, replacing with U+FFFD");
                    }
                    if (String[CodePoint] <= 0x7F) {
                        EncodedString[CodeUnitNum]     = String[CodePoint];
                        CodeUnitNum                   += 1;
                    } else if (String[CodePoint] >= 0x80 && String[CodePoint] <= 0x7FF) {
                        EncodedString[CodeUnitNum]     = (0xC0 & ((String[CodePoint] & 0x7C0) >> 6));
                        EncodedString[CodeUnitNum + 1] = (0x80 &  (String[CodePoint] & 0x03F));
                        CodeUnitNum                   += 2;
                    }  else if (String[CodePoint] >= 0x800 && String[CodePoint] <= 0xFFFF) {
                        EncodedString[CodeUnitNum]     = (0xE0 & ((String[CodePoint] & 0x03F000) >> 12));
                        EncodedString[CodeUnitNum + 1] = (0x80 & ((String[CodePoint] & 0x000FC0) >>  6));
                        EncodedString[CodeUnitNum + 2] = (0x80 &  (String[CodePoint] & 0x00003F));
                        CodeUnitNum                   += 3;
                    } else if (String[CodePoint] >= 0x10000 && String[CodePoint] <= 0x10FFFF) {
                        EncodedString[CodeUnitNum]     = (0xF0 & ((String[CodePoint] & 0x1C0000) >> 18));
                        EncodedString[CodeUnitNum + 1] = (0x80 & ((String[CodePoint] & 0x03F000) >> 12));
                        EncodedString[CodeUnitNum + 2] = (0x80 & ((String[CodePoint] & 0x000FC0) >>  6));
                        EncodedString[CodeUnitNum + 3] = (0x80 &  (String[CodePoint] & 0x00003F));
                        CodeUnitNum                   += 4;
                    }
                } while (String[CodePoint] != 0);
            } else {
                BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL, not enough memory");
            }
        } else {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL");
        }
        return EncodedString;
    }
    
    UTF32String         UTF16String_Decode(UTF16String String) {
        uint64_t CodePoint          = 0ULL;
        uint64_t CodeUnitNum        = 0ULL;
        UTF32String DecodedString   = NULL;
        if (String != NULL) {
            uint64_t UTF16CodeUnits = UTF16String_GetNumCodePoints(String) + UnicodeNULLTerminatorSize;
            DecodedString           = calloc(UTF16CodeUnits, sizeof(UTF32String));
            if (DecodedString != NULL) {
                do {
                    if (CodePoint == 0) {
                        // set the Unicode BOM
#if   (RuntimeByteOrder == LSByte)
                        DecodedString[0] = 0xFFFE;
#elif (RuntimeByteOrder == MSByte)
                        DecodedString[0] = 0xFEFF;
#endif
                    }
                    
                    if (String[CodeUnitNum] <= 0xD7FF || (String[CodeUnitNum] >= 0xE000 && String[CodeUnitNum] <= 0xFFFF)) {
                        DecodedString[CodePoint] = String[CodeUnitNum - 1];
                    } else {
                        DecodedString[CodePoint] = (((String[CodeUnitNum - 1] - 0xD800) * 0x400) + (String[CodeUnitNum] - 0xDC00) + 0x10000);
                    }
                } while (String[CodePoint] != 0);
            } else {
                BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL, not enough memory");
            }
        } else {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL");
        }
        return DecodedString;
    }
    
    UTF16String         UTF16String_Encode(UTF32String String) {
        uint8_t  CodePointSize         = 0;
        uint64_t CodeUnitNum           = 0ULL;
        UTF16String EncodedString      = NULL;
        if (String != NULL) {
            uint64_t UTF16NumCodeUnits = UTF32String_GetNumCodeUnits4UTF16(String) + UnicodeBOMSize + UnicodeNULLTerminatorSize;
            EncodedString              = calloc(UTF16NumCodeUnits, sizeof(UTF16String));
            if (EncodedString != NULL) {
                for (uint64_t CodeUnit = 0ULL; CodeUnit < UTF16NumCodeUnits; CodeUnit++) {
                    // High = ((String[CodePoint] - 0x10000) / 0x400) + 0xD800
                    // Low  = (String[CodePoint]  - 0x10000) % 0x400) + 0xDC00
                    // High = 0x1F984 - 0x10000 = 0xF984 / 0x400 = 0x3E  + 0xD800 = 0xD83E
                    // Low  = 0x1F984 - 0x10000 = 0xF984 % 0x400 = 0x184 + 0xDC00 = 0xDD84
                    if (CodeUnit == 0) {
                        // set the Unicode BOM
#if   (RuntimeByteOrder == LSByte)
                        EncodedString[0] = 0xFFFE;
#elif (RuntimeByteOrder == MSByte)
                        EncodedString[0] = 0xFEFF;
#endif
                    }
                    if (String[CodeUnitNum] <= 0xD7FF || (String[CodeUnitNum] >= 0xE000 && String[CodeUnitNum] <= 0xFFFF)) { // Single code point
                        EncodedString[CodeUnitNum]         = String[CodeUnit];
                    } else {
#if  (RuntimeByteOrder == LSByte) // little endian
                            EncodedString[CodeUnitNum]     = ((String[CodeUnitNum - 1] - 0x10000) % 0x400) + 0xDC00;
                            EncodedString[CodeUnitNum + 1] = ((String[CodeUnitNum] - 0x10000) / 0x400) + 0xD800;
#elif (RuntimeByteOrder == MSByte) // big endian
                            EncodedString[CodeUnitNum]     = ((String[CodeUnitNum - 1] - 0x10000) / 0x400) + 0xD800;
                            EncodedString[CodeUnitNum + 1] = ((String[CodeUnitNum] - 0x10000) % 0x400) + 0xDC00;
#endif
                    }
                }
            } else {
                BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"EncodedString Pointer is NULL, not enough memory");
            }
        } else {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL");
        }
        return EncodedString;
    }
    
    UTF16String UTF16String_ConvertByteOrder(UTF16String String2Convert, UnicodeByteOrder TargetByteOrder) {
        uint16_t         UTF16ByteOrder                = String2Convert[0];
        UnicodeByteOrder CurrentByteOrder              = UnicodeUnknownOrder;
        if (UTF16ByteOrder == 0xFEFF) {
            CurrentByteOrder = UnicodeLittleEndian;
        } else if (UTF16ByteOrder == 0xFFFE) {
            CurrentByteOrder = UnicodeBigEndian;
        }
        uint64_t         CurrentCodePoint              = 1ULL;
        uint8_t          HighByte                      = 0;
        uint8_t          LowByte                       = 0;
        if (CurrentByteOrder != TargetByteOrder) {
            do {
                HighByte                               = (String2Convert[CurrentCodePoint] & 0xFF00) >> 8;
                LowByte                                = (String2Convert[CurrentCodePoint] & 0x00FF);
                String2Convert[CurrentCodePoint]       = (LowByte & HighByte);
            } while (String2Convert[CurrentCodePoint] != 0);
        }
        return String2Convert;
    }
    
    UTF32String UTF32String_ConvertByteOrder(UTF32String String2Convert, UnicodeByteOrder TargetByteOrder) {
        uint32_t         UTF32ByteOrder                = String2Convert[0];
        UnicodeByteOrder CurrentByteOrder              = UnicodeUnknownOrder;
        if (UTF32ByteOrder == 0xFEFF) {
            CurrentByteOrder = UnicodeLittleEndian;
        } else if (UTF32ByteOrder == 0xFFFE) {
            CurrentByteOrder = UnicodeBigEndian;
        }
        uint64_t         CurrentCodePoint              = 1ULL;
        uint8_t          Byte0                         = 0;
        uint8_t          Byte1                         = 0;
        uint8_t          Byte2                         = 0;
        uint8_t          Byte3                         = 0;
        if (CurrentByteOrder != TargetByteOrder) {
            do {
                Byte0                                  = (String2Convert[CurrentCodePoint] & 0xFF000000) >> 24;
                Byte1                                  = (String2Convert[CurrentCodePoint] & 0x00FF0000) >> 16;
                Byte2                                  = (String2Convert[CurrentCodePoint] & 0x0000FF00) >>  8;
                Byte3                                  = (String2Convert[CurrentCodePoint] & 0x000000FF);
                String2Convert[CurrentCodePoint]       = (Byte0 & (Byte1 << 8) & (Byte2 << 16) & (Byte3 << 24));
            } while (String2Convert[CurrentCodePoint] != 0);
        }
        return String2Convert;
    }
    
    static const UTF32CodePoint WhitespaceTable[WhitespaceTableSize] = {
        0x00009, 0x0000A, 0x0000B, 0x0000C, 0x0000D, 0x00020,
        0x00085, 0x000A0, 0x01680, 0x02001, 0x02002, 0x02003,
        0x02004, 0x02005, 0x02006, 0x02007, 0x02008, 0x02009,
        0x0200A, 0x02028, 0x02029, 0x0202F, 0x0205F, 0x03000,
        0x0200B, 0x0200C, 0x0200D, 0x02060, 0x0FEFF, 0x0FFFE
    };
    /*
    static const UTF32CodePoint NormalizationTable[NormalizationTableIndex][NormalizationTableNumDiacritics][NormalizationTableBaseCodePoint][NormalizationTableDiacritics][NormalizationTablePrecomposed] = {  // NumDiacritics, Base, Diacritics, Precomposed
        {1, 0x0041, 0x030F, 0x0200}, {1, 0x0061, 0x030F, 0x0201},
        {1, 0x0041, 0x0311, 0x0202}, {1, 0x0061, 0x0311, 0x0203},
        {1, 0x0045, 0x030F, 0x0204}, {1, 0x0065, 0x030F, 0x0205},
        {1, 0x0045, 0x0311, 0x0206}, {1, 0x0045, 0x0311, 0x0206},
        {1, 0x0065, 0x0311, 0x0207}, {1, 0x0049, 0x030F, 0x0208},
        {1, 0x0069, 0x030F, 0x0209}, {1, 0x0049, 0x0311, 0x020A},
        {1, 0x0069, 0x0311, 0x020B}, {1, 0x004F, 0x030F, 0x020C},
        {1, 0x006F, 0x030F, 0x020D}, {1, 0x004F, 0x0311, 0x020E},
        {1, 0x006F, 0x0311, 0x020F}, {1, 0x0052, 0x030F, 0x0210},
        {1, 0x0072, 0x030F, 0x0211}, {1, 0x0052, 0x0311, 0x0212},
        {1, 0x0072, 0x0311, 0x0213}, {1, 0x0055, 0x030F, 0x0214},
        {1, 0x0075, 0x030F, 0x0215}, {1, 0x0055, 0x0311, 0x0216},
        {1, 0x0075, 0x0311, 0x0217}, {1, 0x0053, 0x0326, 0x0218},
        {1, 0x0073, 0x0326, 0x0219}, {1, 0x0054, 0x0326, 0x021A},
        {1, 0x0074, 0x0326, 0x021B}, {1, 0x0048, 0x030C, 0x021E},
        {1, 0x0041, 0x0307, 0x0226}, {1, 0x0061, 0x0307, 0x0227},
        {1, 0x0045, 0x0327, 0x0228}, {1, 0x0065, 0x0327, 0x0229},
        {1, 0x004F, 0x0307, 0x022E}, {1, 0x006F, 0x0307, 0x022F},
        {1, 0x0059, 0x0304, 0x0232}, {1, 0x0079, 0x0304, 0x0233},
        {2, 0x004F, 0x0308, 0x0304, 0x022A},
        {2, 0x006F, 0x0308, 0x0304, 0x022B},
        {2, 0x004F, 0x0303, 0x0304, 0x022C},
        {2, 0x006F, 0x0303, 0x0304, 0x022D},
        {2, 0x004F, 0x0307, 0x0304, 0x0230},
        {2, 0x006F, 0x0307, 0x0304, 0x0231},
        {2, 0x006F, 0x0307, 0x0304, 0x0231},
    };
     */
    
    static const UTF32CodePoint NormalizationTablePrecomposed[26] = {
        0x200, 0x201
    };
    
    static const UTF32CodePoint SimpleCaseFoldTable[SimpleCaseFoldTableSize][2] = {
        {0x00041, 0x00061}, {0x00042, 0x00062}, {0x00043, 0x00063}, {0x00044, 0x00064},
        {0x00045, 0x00065}, {0x00046, 0x00066}, {0x00047, 0x00067}, {0x00048, 0x00068},
        {0x00049, 0x00069}, {0x0004A, 0x0006A}, {0x0004B, 0x0006B}, {0x0004C, 0x0006C},
        {0x0004D, 0x0006D}, {0x0004E, 0x0006E}, {0x0004F, 0x0006F}, {0x00050, 0x00070},
        {0x00051, 0x00071}, {0x00052, 0x00072}, {0x00053, 0x00073}, {0x00054, 0x00074},
        {0x00055, 0x00075}, {0x00056, 0x00076}, {0x00057, 0x00077}, {0x00058, 0x00078},
        {0x00059, 0x00079}, {0x0005A, 0x0007A}, {0x000B5, 0x003BC}, {0x000C0, 0x000E0},
        {0x000C1, 0x000E1}, {0x000C2, 0x000E2}, {0x000C3, 0x000E3}, {0x000C4, 0x000E4},
        {0x000C5, 0x000E5}, {0x000C6, 0x000E6}, {0x000C7, 0x000E7}, {0x000C8, 0x000E8},
        {0x000C9, 0x000E9}, {0x000CA, 0x000EA}, {0x000CB, 0x000EB}, {0x000CC, 0x000EC},
        {0x000CD, 0x000ED}, {0x000CE, 0x000EE}, {0x000CF, 0x000EF}, {0x000D0, 0x000F0},
        {0x000D1, 0x000F1}, {0x000D2, 0x000F2}, {0x000D3, 0x000F3}, {0x000D4, 0x000F4},
        {0x000D5, 0x000F5}, {0x000D6, 0x000F6}, {0x000D8, 0x000F8}, {0x000D9, 0x000F9},
        {0x000DA, 0x000FA}, {0x000DB, 0x000FB}, {0x000DC, 0x000FC}, {0x000DD, 0x000FD},
        {0x000DE, 0x000FE}, {0x00100, 0x00101}, {0x00102, 0x00103}, {0x00104, 0x00105},
        {0x00106, 0x00107}, {0x00108, 0x00109}, {0x0010A, 0x0010B}, {0x0010C, 0x0010D},
        {0x0010E, 0x0010F}, {0x00110, 0x00111}, {0x00112, 0x00113}, {0x00114, 0x00115},
        {0x00116, 0x00117}, {0x00118, 0x00119}, {0x0011A, 0x0011B}, {0x0011C, 0x0011D},
        {0x0011E, 0x0011F}, {0x00120, 0x00121}, {0x00122, 0x00123}, {0x00124, 0x00125},
        {0x00126, 0x00127}, {0x00128, 0x00129}, {0x0012A, 0x0012B}, {0x0012C, 0x0012D},
        {0x0012E, 0x0012F}, {0x00132, 0x00133}, {0x00134, 0x00135}, {0x00136, 0x00137},
        {0x00139, 0x0013A}, {0x0013B, 0x0013C}, {0x0013D, 0x0013E}, {0x0013F, 0x00140},
        {0x00141, 0x00142}, {0x00143, 0x00144}, {0x00145, 0x00146}, {0x00147, 0x00148},
        {0x0014A, 0x0014B}, {0x0014C, 0x0014D}, {0x0014E, 0x0014F}, {0x00150, 0x00151},
        {0x00152, 0x00153}, {0x00154, 0x00155}, {0x00156, 0x00157}, {0x00158, 0x00159},
        {0x0015A, 0x0015B}, {0x0015C, 0x0015D}, {0x0015E, 0x0015F}, {0x00160, 0x00161},
        {0x00162, 0x00163}, {0x00164, 0x00165}, {0x00166, 0x00167}, {0x00168, 0x00169},
        {0x0016A, 0x0016B}, {0x0016C, 0x0016D}, {0x0016E, 0x0016F}, {0x00170, 0x00171},
        {0x00172, 0x00173}, {0x00174, 0x00175}, {0x00176, 0x00177}, {0x00178, 0x000FF},
        {0x00179, 0x0017A}, {0x0017B, 0x0017C}, {0x0017D, 0x0017E}, {0x0017F, 0x00073},
        {0x00181, 0x00253}, {0x00182, 0x00183}, {0x00184, 0x00185}, {0x00186, 0x00254},
        {0x00187, 0x00188}, {0x00189, 0x00256}, {0x0018A, 0x00257}, {0x0018B, 0x0018C},
        {0x0018E, 0x001DD}, {0x0018F, 0x00259}, {0x00190, 0x0025B}, {0x00191, 0x00192},
        {0x00193, 0x00260}, {0x00194, 0x00263}, {0x00196, 0x00269}, {0x00197, 0x00268},
        {0x00198, 0x00199}, {0x0019C, 0x0026F}, {0x0019D, 0x00272}, {0x0019F, 0x00275},
        {0x001A0, 0x001A1}, {0x001A2, 0x001A3}, {0x001A4, 0x001A5}, {0x001A6, 0x00280},
        {0x001A7, 0x001A8}, {0x001A9, 0x00283}, {0x001AC, 0x001AD}, {0x001AE, 0x00288},
        {0x001AF, 0x001B0}, {0x001B1, 0x0028A}, {0x001B2, 0x0028B}, {0x001B3, 0x001B4},
        {0x001B5, 0x001B6}, {0x001B7, 0x00292}, {0x001B8, 0x001B9}, {0x001BC, 0x001BD},
        {0x001C4, 0x001C6}, {0x001C5, 0x001C6}, {0x001C7, 0x001C9}, {0x001C8, 0x001C9},
        {0x001CA, 0x001CC}, {0x001CB, 0x001CC}, {0x001CD, 0x001CE}, {0x001CF, 0x001D0},
        {0x001D1, 0x001D2}, {0x001D3, 0x001D4}, {0x001D5, 0x001D6}, {0x001D7, 0x001D8},
        {0x001D9, 0x001DA}, {0x001DB, 0x001DC}, {0x001DE, 0x001DF}, {0x001E0, 0x001E1},
        {0x001E2, 0x001E3}, {0x001E4, 0x001E5}, {0x001E6, 0x001E7}, {0x001E8, 0x001E9},
        {0x001EA, 0x001EB}, {0x001EC, 0x001ED}, {0x001EE, 0x001EF}, {0x001F1, 0x001F3},
        {0x001F2, 0x001F3}, {0x001F4, 0x001F5}, {0x001F6, 0x00195}, {0x001F7, 0x001BF},
        {0x001F8, 0x001F9}, {0x001FA, 0x001FB}, {0x001FC, 0x001FD}, {0x001FE, 0x001FF},
        {0x00200, 0x00201}, {0x00202, 0x00203}, {0x00204, 0x00205}, {0x00206, 0x00207},
        {0x00208, 0x00209}, {0x0020A, 0x0020B}, {0x0020C, 0x0020D}, {0x0020E, 0x0020F},
        {0x00210, 0x00211}, {0x00212, 0x00213}, {0x00214, 0x00215}, {0x00216, 0x00217},
        {0x00218, 0x00219}, {0x0021A, 0x0021B}, {0x0021C, 0x0021D}, {0x0021E, 0x0021F},
        {0x00220, 0x0019E}, {0x00222, 0x00223}, {0x00224, 0x00225}, {0x00226, 0x00227},
        {0x00228, 0x00229}, {0x0022A, 0x0022B}, {0x0022C, 0x0022D}, {0x0022E, 0x0022F},
        {0x00230, 0x00231}, {0x00232, 0x00233}, {0x0023A, 0x02C65}, {0x0023B, 0x0023C},
        {0x0023D, 0x0019A}, {0x0023E, 0x02C66}, {0x00241, 0x00242}, {0x00243, 0x00180},
        {0x00244, 0x00289}, {0x00245, 0x0028C}, {0x00246, 0x00247}, {0x00248, 0x00249},
        {0x0024A, 0x0024B}, {0x0024C, 0x0024D}, {0x0024E, 0x0024F}, {0x00345, 0x003B9},
        {0x00370, 0x00371}, {0x00372, 0x00373}, {0x00376, 0x00377}, {0x0037F, 0x003F3},
        {0x00386, 0x003AC}, {0x00388, 0x003AD}, {0x00389, 0x003AE}, {0x0038A, 0x003AF},
        {0x0038C, 0x003CC}, {0x0038E, 0x003CD}, {0x0038F, 0x003CE}, {0x00391, 0x003B1},
        {0x00392, 0x003B2}, {0x00393, 0x003B3}, {0x00394, 0x003B4}, {0x00395, 0x003B5},
        {0x00396, 0x003B6}, {0x00397, 0x003B7}, {0x00398, 0x003B8}, {0x00399, 0x003B9},
        {0x0039A, 0x003BA}, {0x0039B, 0x003BB}, {0x0039C, 0x003BC}, {0x0039D, 0x003BD},
        {0x0039E, 0x003BE}, {0x0039F, 0x003BF}, {0x003A0, 0x003C0}, {0x003A1, 0x003C1},
        {0x003A3, 0x003C3}, {0x003A4, 0x003C4}, {0x003A5, 0x003C5}, {0x003A6, 0x003C6},
        {0x003A7, 0x003C7}, {0x003A8, 0x003C8}, {0x003A9, 0x003C9}, {0x003AA, 0x003CA},
        {0x003AB, 0x003CB}, {0x003C2, 0x003C3}, {0x003CF, 0x003D7}, {0x003D0, 0x003B2},
        {0x003D1, 0x003B8}, {0x003D5, 0x003C6}, {0x003D6, 0x003C0}, {0x003D8, 0x003D9},
        {0x003DA, 0x003DB}, {0x003DC, 0x003DD}, {0x003DE, 0x003DF}, {0x003E0, 0x003E1},
        {0x003E2, 0x003E3}, {0x003E4, 0x003E5}, {0x003E6, 0x003E7}, {0x003E8, 0x003E9},
        {0x003EA, 0x003EB}, {0x003EC, 0x003ED}, {0x003EE, 0x003EF}, {0x003F0, 0x003BA},
        {0x003F1, 0x003C1}, {0x003F4, 0x003B8}, {0x003F5, 0x003B5}, {0x003F7, 0x003F8},
        {0x003F9, 0x003F2}, {0x003FA, 0x003FB}, {0x003FD, 0x0037B}, {0x003FE, 0x0037C},
        {0x003FF, 0x0037D}, {0x00400, 0x00450}, {0x00401, 0x00451}, {0x00402, 0x00452},
        {0x00403, 0x00453}, {0x00404, 0x00454}, {0x00405, 0x00455}, {0x00406, 0x00456},
        {0x00407, 0x00457}, {0x00408, 0x00458}, {0x00409, 0x00459}, {0x0040A, 0x0045A},
        {0x0040B, 0x0045B}, {0x0040C, 0x0045C}, {0x0040D, 0x0045D}, {0x0040E, 0x0045E},
        {0x0040F, 0x0045F}, {0x00410, 0x00430}, {0x00411, 0x00431}, {0x00412, 0x00432},
        {0x00413, 0x00433}, {0x00414, 0x00434}, {0x00415, 0x00435}, {0x00416, 0x00436},
        {0x00417, 0x00437}, {0x00418, 0x00438}, {0x00419, 0x00439}, {0x0041A, 0x0043A},
        {0x0041B, 0x0043B}, {0x0041C, 0x0043C}, {0x0041D, 0x0043D}, {0x0041E, 0x0043E},
        {0x0041F, 0x0043F}, {0x00420, 0x00440}, {0x00421, 0x00441}, {0x00422, 0x00442},
        {0x00423, 0x00443}, {0x00424, 0x00444}, {0x00425, 0x00445}, {0x00426, 0x00446},
        {0x00427, 0x00447}, {0x00428, 0x00448}, {0x00429, 0x00449}, {0x0042A, 0x0044A},
        {0x0042B, 0x0044B}, {0x0042C, 0x0044C}, {0x0042D, 0x0044D}, {0x0042E, 0x0044E},
        {0x0042F, 0x0044F}, {0x00460, 0x00461}, {0x00462, 0x00463}, {0x00464, 0x00465},
        {0x00466, 0x00467}, {0x00468, 0x00469}, {0x0046A, 0x0046B}, {0x0046C, 0x0046D},
        {0x0046E, 0x0046F}, {0x00470, 0x00471}, {0x00472, 0x00473}, {0x00474, 0x00475},
        {0x00476, 0x00477}, {0x00478, 0x00479}, {0x0047A, 0x0047B}, {0x0047C, 0x0047D},
        {0x0047E, 0x0047F}, {0x00480, 0x00481}, {0x0048A, 0x0048B}, {0x0048C, 0x0048D},
        {0x0048E, 0x0048F}, {0x00490, 0x00491}, {0x00492, 0x00493}, {0x00494, 0x00495},
        {0x00496, 0x00497}, {0x00498, 0x00499}, {0x0049A, 0x0049B}, {0x0049C, 0x0049D},
        {0x0049E, 0x0049F}, {0x004A0, 0x004A1}, {0x004A2, 0x004A3}, {0x004A4, 0x004A5},
        {0x004A6, 0x004A7}, {0x004A8, 0x004A9}, {0x004AA, 0x004AB}, {0x004AC, 0x004AD},
        {0x004AE, 0x004AF}, {0x004B0, 0x004B1}, {0x004B2, 0x004B3}, {0x004B4, 0x004B5},
        {0x004B6, 0x004B7}, {0x004B8, 0x004B9}, {0x004BA, 0x004BB}, {0x004BC, 0x004BD},
        {0x004BE, 0x004BF}, {0x004C0, 0x004CF}, {0x004C1, 0x004C2}, {0x004C3, 0x004C4},
        {0x004C5, 0x004C6}, {0x004C7, 0x004C8}, {0x004C9, 0x004CA}, {0x004CB, 0x004CC},
        {0x004CD, 0x004CE}, {0x004D0, 0x004D1}, {0x004D2, 0x004D3}, {0x004D4, 0x004D5},
        {0x004D6, 0x004D7}, {0x004D8, 0x004D9}, {0x004DA, 0x004DB}, {0x004DC, 0x004DD},
        {0x004DE, 0x004DF}, {0x004E0, 0x004E1}, {0x004E2, 0x004E3}, {0x004E4, 0x004E5},
        {0x004E6, 0x004E7}, {0x004E8, 0x004E9}, {0x004EA, 0x004EB}, {0x004EC, 0x004ED},
        {0x004EE, 0x004EF}, {0x004F0, 0x004F1}, {0x004F2, 0x004F3}, {0x004F4, 0x004F5},
        {0x004F6, 0x004F7}, {0x004F8, 0x004F9}, {0x004FA, 0x004FB}, {0x004FC, 0x004FD},
        {0x004FE, 0x004FF}, {0x00500, 0x00501}, {0x00502, 0x00503}, {0x00504, 0x00505},
        {0x00506, 0x00507}, {0x00508, 0x00509}, {0x0050A, 0x0050B}, {0x0050C, 0x0050D},
        {0x0050E, 0x0050F}, {0x00510, 0x00511}, {0x00512, 0x00513}, {0x00514, 0x00515},
        {0x00516, 0x00517}, {0x00518, 0x00519}, {0x0051A, 0x0051B}, {0x0051C, 0x0051D},
        {0x0051E, 0x0051F}, {0x00520, 0x00521}, {0x00522, 0x00523}, {0x00524, 0x00525},
        {0x00526, 0x00527}, {0x00528, 0x00529}, {0x0052A, 0x0052B}, {0x0052C, 0x0052D},
        {0x0052E, 0x0052F}, {0x00531, 0x00561}, {0x00532, 0x00562}, {0x00533, 0x00563},
        {0x00534, 0x00564}, {0x00535, 0x00565}, {0x00536, 0x00566}, {0x00537, 0x00567},
        {0x00538, 0x00568}, {0x00539, 0x00569}, {0x0053A, 0x0056A}, {0x0053B, 0x0056B},
        {0x0053C, 0x0056C}, {0x0053D, 0x0056D}, {0x0053E, 0x0056E}, {0x0053F, 0x0056F},
        {0x00540, 0x00570}, {0x00541, 0x00571}, {0x00542, 0x00572}, {0x00543, 0x00573},
        {0x00544, 0x00574}, {0x00545, 0x00575}, {0x00546, 0x00576}, {0x00547, 0x00577},
        {0x00548, 0x00578}, {0x00549, 0x00579}, {0x0054A, 0x0057A}, {0x0054B, 0x0057B},
        {0x0054C, 0x0057C}, {0x0054D, 0x0057D}, {0x0054E, 0x0057E}, {0x0054F, 0x0057F},
        {0x00550, 0x00580}, {0x00551, 0x00581}, {0x00552, 0x00582}, {0x00553, 0x00583},
        {0x00554, 0x00584}, {0x00555, 0x00585}, {0x00556, 0x00586}, {0x010A0, 0x02D00},
        {0x010A1, 0x02D01}, {0x010A2, 0x02D02}, {0x010A3, 0x02D03}, {0x010A4, 0x02D04},
        {0x010A5, 0x02D05}, {0x010A6, 0x02D06}, {0x010A7, 0x02D07}, {0x010A8, 0x02D08},
        {0x010A9, 0x02D09}, {0x010AA, 0x02D0A}, {0x010AB, 0x02D0B}, {0x010AC, 0x02D0C},
        {0x010AD, 0x02D0D}, {0x010AE, 0x02D0E}, {0x010AF, 0x02D0F}, {0x010B0, 0x02D10},
        {0x010B1, 0x02D11}, {0x010B2, 0x02D12}, {0x010B3, 0x02D13}, {0x010B4, 0x02D14},
        {0x010B5, 0x02D15}, {0x010B6, 0x02D16}, {0x010B7, 0x02D17}, {0x010B8, 0x02D18},
        {0x010B9, 0x02D19}, {0x010BA, 0x02D1A}, {0x010BB, 0x02D1B}, {0x010BC, 0x02D1C},
        {0x010BD, 0x02D1D}, {0x010BE, 0x02D1E}, {0x010BF, 0x02D1F}, {0x010C0, 0x02D20},
        {0x010C1, 0x02D21}, {0x010C2, 0x02D22}, {0x010C3, 0x02D23}, {0x010C4, 0x02D24},
        {0x010C5, 0x02D25}, {0x010C7, 0x02D27}, {0x010CD, 0x02D2D}, {0x013F8, 0x013F0},
        {0x013F9, 0x013F1}, {0x013FA, 0x013F2}, {0x013FB, 0x013F3}, {0x013FC, 0x013F4},
        {0x013FD, 0x013F5}, {0x01C80, 0x00432}, {0x01C81, 0x00434}, {0x01C82, 0x0043E},
        {0x01C83, 0x00441}, {0x01C84, 0x00442}, {0x01C85, 0x00442}, {0x01C86, 0x0044A},
        {0x01C87, 0x00463}, {0x01C88, 0x0A64B}, {0x01E00, 0x01E01}, {0x01E02, 0x01E03},
        {0x01E04, 0x01E05}, {0x01E06, 0x01E07}, {0x01E08, 0x01E09}, {0x01E0A, 0x01E0B},
        {0x01E0C, 0x01E0D}, {0x01E0E, 0x01E0F}, {0x01E10, 0x01E11}, {0x01E12, 0x01E13},
        {0x01E14, 0x01E15}, {0x01E16, 0x01E17}, {0x01E18, 0x01E19}, {0x01E1A, 0x01E1B},
        {0x01E1C, 0x01E1D}, {0x01E1E, 0x01E1F}, {0x01E20, 0x01E21}, {0x01E22, 0x01E23},
        {0x01E24, 0x01E25}, {0x01E26, 0x01E27}, {0x01E28, 0x01E29}, {0x01E2A, 0x01E2B},
        {0x01E2C, 0x01E2D}, {0x01E2E, 0x01E2F}, {0x01E30, 0x01E31}, {0x01E32, 0x01E33},
        {0x01E34, 0x01E35}, {0x01E36, 0x01E37}, {0x01E38, 0x01E39}, {0x01E3A, 0x01E3B},
        {0x01E3C, 0x01E3D}, {0x01E3E, 0x01E3F}, {0x01E40, 0x01E41}, {0x01E42, 0x01E43},
        {0x01E44, 0x01E45}, {0x01E46, 0x01E47}, {0x01E48, 0x01E49}, {0x01E4A, 0x01E4B},
        {0x01E4C, 0x01E4D}, {0x01E4E, 0x01E4F}, {0x01E50, 0x01E51}, {0x01E52, 0x01E53},
        {0x01E54, 0x01E55}, {0x01E56, 0x01E57}, {0x01E58, 0x01E59}, {0x01E5A, 0x01E5B},
        {0x01E5C, 0x01E5D}, {0x01E5E, 0x01E5F}, {0x01E60, 0x01E61}, {0x01E62, 0x01E63},
        {0x01E64, 0x01E65}, {0x01E66, 0x01E67}, {0x01E68, 0x01E69}, {0x01E6A, 0x01E6B},
        {0x01E6C, 0x01E6D}, {0x01E6E, 0x01E6F}, {0x01E70, 0x01E71}, {0x01E72, 0x01E73},
        {0x01E74, 0x01E75}, {0x01E76, 0x01E77}, {0x01E78, 0x01E79}, {0x01E7A, 0x01E7B},
        {0x01E7C, 0x01E7D}, {0x01E7E, 0x01E7F}, {0x01E80, 0x01E81}, {0x01E82, 0x01E83},
        {0x01E84, 0x01E85}, {0x01E86, 0x01E87}, {0x01E88, 0x01E89}, {0x01E8A, 0x01E8B},
        {0x01E8C, 0x01E8D}, {0x01E8E, 0x01E8F}, {0x01E90, 0x01E91}, {0x01E92, 0x01E93},
        {0x01E94, 0x01E95}, {0x01E9B, 0x01E61}, {0x01EA0, 0x01EA1}, {0x01EA2, 0x01EA3},
        {0x01EA4, 0x01EA5}, {0x01EA6, 0x01EA7}, {0x01EA8, 0x01EA9}, {0x01EAA, 0x01EAB},
        {0x01EAC, 0x01EAD}, {0x01EAE, 0x01EAF}, {0x01EB0, 0x01EB1}, {0x01EB2, 0x01EB3},
        {0x01EB4, 0x01EB5}, {0x01EB6, 0x01EB7}, {0x01EB8, 0x01EB9}, {0x01EBA, 0x01EBB},
        {0x01EBC, 0x01EBD}, {0x01EBE, 0x01EBF}, {0x01EC0, 0x01EC1}, {0x01EC2, 0x01EC3},
        {0x01EC4, 0x01EC5}, {0x01EC6, 0x01EC7}, {0x01EC8, 0x01EC9}, {0x01ECA, 0x01ECB},
        {0x01ECC, 0x01ECD}, {0x01ECE, 0x01ECF}, {0x01ED0, 0x01ED1}, {0x01ED2, 0x01ED3},
        {0x01ED4, 0x01ED5}, {0x01ED6, 0x01ED7}, {0x01ED8, 0x01ED9}, {0x01EDA, 0x01EDB},
        {0x01EDC, 0x01EDD}, {0x01EDE, 0x01EDF}, {0x01EE0, 0x01EE1}, {0x01EE2, 0x01EE3},
        {0x01EE4, 0x01EE5}, {0x01EE6, 0x01EE7}, {0x01EE8, 0x01EE9}, {0x01EEA, 0x01EEB},
        {0x01EEC, 0x01EED}, {0x01EEE, 0x01EEF}, {0x01EF0, 0x01EF1}, {0x01EF2, 0x01EF3},
        {0x01EF4, 0x01EF5}, {0x01EF6, 0x01EF7}, {0x01EF8, 0x01EF9}, {0x01EFA, 0x01EFB},
        {0x01EFC, 0x01EFD}, {0x01EFE, 0x01EFF}, {0x01F08, 0x01F00}, {0x01F09, 0x01F01},
        {0x01F0A, 0x01F02}, {0x01F0B, 0x01F03}, {0x01F0C, 0x01F04}, {0x01F0D, 0x01F05},
        {0x01F0E, 0x01F06}, {0x01F0F, 0x01F07}, {0x01F18, 0x01F10}, {0x01F19, 0x01F11},
        {0x01F1A, 0x01F12}, {0x01F1B, 0x01F13}, {0x01F1C, 0x01F14}, {0x01F1D, 0x01F15},
        {0x01F28, 0x01F20}, {0x01F29, 0x01F21}, {0x01F2A, 0x01F22}, {0x01F2B, 0x01F23},
        {0x01F2C, 0x01F24}, {0x01F2D, 0x01F25}, {0x01F2E, 0x01F26}, {0x01F2F, 0x01F27},
        {0x01F38, 0x01F30}, {0x01F39, 0x01F31}, {0x01F3A, 0x01F32}, {0x01F3B, 0x01F33},
        {0x01F3C, 0x01F34}, {0x01F3D, 0x01F35}, {0x01F3E, 0x01F36}, {0x01F3F, 0x01F37},
        {0x01F48, 0x01F40}, {0x01F49, 0x01F41}, {0x01F4A, 0x01F42}, {0x01F4B, 0x01F43},
        {0x01F4C, 0x01F44}, {0x01F4D, 0x01F45}, {0x01F59, 0x01F51}, {0x01F5B, 0x01F53},
        {0x01F5D, 0x01F55}, {0x01F5F, 0x01F57}, {0x01F68, 0x01F60}, {0x01F69, 0x01F61},
        {0x01F6A, 0x01F62}, {0x01F6B, 0x01F63}, {0x01F6C, 0x01F64}, {0x01F6D, 0x01F65},
        {0x01F6E, 0x01F66}, {0x01F6F, 0x01F67}, {0x01FB8, 0x01FB0}, {0x01FB9, 0x01FB1},
        {0x01FBA, 0x01F70}, {0x01FBB, 0x01F71}, {0x01FBE, 0x003B9}, {0x01FC8, 0x01F72},
        {0x01FC9, 0x01F73}, {0x01FCA, 0x01F74}, {0x01FCB, 0x01F75}, {0x01FD8, 0x01FD0},
        {0x01FD9, 0x01FD1}, {0x01FDA, 0x01F76}, {0x01FDB, 0x01F77}, {0x01FE8, 0x01FE0},
        {0x01FE9, 0x01FE1}, {0x01FEA, 0x01F7A}, {0x01FEB, 0x01F7B}, {0x01FEC, 0x01FE5},
        {0x01FF8, 0x01F78}, {0x01FF9, 0x01F79}, {0x01FFA, 0x01F7C}, {0x01FFB, 0x01F7D},
        {0x02126, 0x003C9}, {0x0212A, 0x0006B}, {0x0212B, 0x000E5}, {0x02132, 0x0214E},
        {0x02160, 0x02170}, {0x02161, 0x02171}, {0x02162, 0x02172}, {0x02163, 0x02173},
        {0x02164, 0x02174}, {0x02165, 0x02175}, {0x02166, 0x02176}, {0x02167, 0x02177},
        {0x02168, 0x02178}, {0x02169, 0x02179}, {0x0216A, 0x0217A}, {0x0216B, 0x0217B},
        {0x0216C, 0x0217C}, {0x0216D, 0x0217D}, {0x0216E, 0x0217E}, {0x0216F, 0x0217F},
        {0x02183, 0x02184}, {0x024B6, 0x024D0}, {0x024B7, 0x024D1}, {0x024B8, 0x024D2},
        {0x024B9, 0x024D3}, {0x024BA, 0x024D4}, {0x024BB, 0x024D5}, {0x024BC, 0x024D6},
        {0x024BD, 0x024D7}, {0x024BE, 0x024D8}, {0x024BF, 0x024D9}, {0x024C0, 0x024DA},
        {0x024C1, 0x024DB}, {0x024C2, 0x024DC}, {0x024C3, 0x024DD}, {0x024C4, 0x024DE},
        {0x024C5, 0x024DF}, {0x024C6, 0x024E0}, {0x024C7, 0x024E1}, {0x024C8, 0x024E2},
        {0x024C9, 0x024E3}, {0x024CA, 0x024E4}, {0x024CB, 0x024E5}, {0x024CC, 0x024E6},
        {0x024CD, 0x024E7}, {0x024CE, 0x024E8}, {0x024CF, 0x024E9}, {0x02C00, 0x02C30},
        {0x02C01, 0x02C31}, {0x02C02, 0x02C32}, {0x02C03, 0x02C33}, {0x02C04, 0x02C34},
        {0x02C05, 0x02C35}, {0x02C06, 0x02C36}, {0x02C07, 0x02C37}, {0x02C08, 0x02C38},
        {0x02C09, 0x02C39}, {0x02C0A, 0x02C3A}, {0x02C0B, 0x02C3B}, {0x02C0C, 0x02C3C},
        {0x02C0D, 0x02C3D}, {0x02C0E, 0x02C3E}, {0x02C0F, 0x02C3F}, {0x02C10, 0x02C40},
        {0x02C11, 0x02C41}, {0x02C12, 0x02C42}, {0x02C13, 0x02C43}, {0x02C14, 0x02C44},
        {0x02C15, 0x02C45}, {0x02C16, 0x02C46}, {0x02C17, 0x02C47}, {0x02C18, 0x02C48},
        {0x02C19, 0x02C49}, {0x02C1A, 0x02C4A}, {0x02C1B, 0x02C4B}, {0x02C1C, 0x02C4C},
        {0x02C1D, 0x02C4D}, {0x02C1E, 0x02C4E}, {0x02C1F, 0x02C4F}, {0x02C20, 0x02C50},
        {0x02C21, 0x02C51}, {0x02C22, 0x02C52}, {0x02C23, 0x02C53}, {0x02C24, 0x02C54},
        {0x02C25, 0x02C55}, {0x02C26, 0x02C56}, {0x02C27, 0x02C57}, {0x02C28, 0x02C58},
        {0x02C29, 0x02C59}, {0x02C2A, 0x02C5A}, {0x02C2B, 0x02C5B}, {0x02C2C, 0x02C5C},
        {0x02C2D, 0x02C5D}, {0x02C2E, 0x02C5E}, {0x02C60, 0x02C61}, {0x02C62, 0x0026B},
        {0x02C63, 0x01D7D}, {0x02C64, 0x0027D}, {0x02C67, 0x02C68}, {0x02C69, 0x02C6A},
        {0x02C6B, 0x02C6C}, {0x02C6D, 0x00251}, {0x02C6E, 0x00271}, {0x02C6F, 0x00250},
        {0x02C70, 0x00252}, {0x02C72, 0x02C73}, {0x02C75, 0x02C76}, {0x02C7E, 0x0023F},
        {0x02C7F, 0x00240}, {0x02C80, 0x02C81}, {0x02C82, 0x02C83}, {0x02C84, 0x02C85},
        {0x02C86, 0x02C87}, {0x02C88, 0x02C89}, {0x02C8A, 0x02C8B}, {0x02C8C, 0x02C8D},
        {0x02C8E, 0x02C8F}, {0x02C90, 0x02C91}, {0x02C92, 0x02C93}, {0x02C94, 0x02C95},
        {0x02C96, 0x02C97}, {0x02C98, 0x02C99}, {0x02C9A, 0x02C9B}, {0x02C9C, 0x02C9D},
        {0x02C9E, 0x02C9F}, {0x02CA0, 0x02CA1}, {0x02CA2, 0x02CA3}, {0x02CA4, 0x02CA5},
        {0x02CA6, 0x02CA7}, {0x02CA8, 0x02CA9}, {0x02CAA, 0x02CAB}, {0x02CAC, 0x02CAD},
        {0x02CAE, 0x02CAF}, {0x02CB0, 0x02CB1}, {0x02CB2, 0x02CB3}, {0x02CB4, 0x02CB5},
        {0x02CB6, 0x02CB7}, {0x02CB8, 0x02CB9}, {0x02CBA, 0x02CBB}, {0x02CBC, 0x02CBD},
        {0x02CBE, 0x02CBF}, {0x02CC0, 0x02CC1}, {0x02CC2, 0x02CC3}, {0x02CC4, 0x02CC5},
        {0x02CC6, 0x02CC7}, {0x02CC8, 0x02CC9}, {0x02CCA, 0x02CCB}, {0x02CCC, 0x02CCD},
        {0x02CCE, 0x02CCF}, {0x02CD0, 0x02CD1}, {0x02CD2, 0x02CD3}, {0x02CD4, 0x02CD5},
        {0x02CD6, 0x02CD7}, {0x02CD8, 0x02CD9}, {0x02CDA, 0x02CDB}, {0x02CDC, 0x02CDD},
        {0x02CDE, 0x02CDF}, {0x02CE0, 0x02CE1}, {0x02CE2, 0x02CE3}, {0x02CEB, 0x02CEC},
        {0x02CED, 0x02CEE}, {0x02CF2, 0x02CF3}, {0x0A640, 0x0A641}, {0x0A642, 0x0A643},
        {0x0A644, 0x0A645}, {0x0A646, 0x0A647}, {0x0A648, 0x0A649}, {0x0A64A, 0x0A64B},
        {0x0A64C, 0x0A64D}, {0x0A64E, 0x0A64F}, {0x0A650, 0x0A651}, {0x0A652, 0x0A653},
        {0x0A654, 0x0A655}, {0x0A656, 0x0A657}, {0x0A658, 0x0A659}, {0x0A65A, 0x0A65B},
        {0x0A65C, 0x0A65D}, {0x0A65E, 0x0A65F}, {0x0A660, 0x0A661}, {0x0A662, 0x0A663},
        {0x0A664, 0x0A665}, {0x0A666, 0x0A667}, {0x0A668, 0x0A669}, {0x0A66A, 0x0A66B},
        {0x0A66C, 0x0A66D}, {0x0A680, 0x0A681}, {0x0A682, 0x0A683}, {0x0A684, 0x0A685},
        {0x0A686, 0x0A687}, {0x0A688, 0x0A689}, {0x0A68A, 0x0A68B}, {0x0A68C, 0x0A68D},
        {0x0A68E, 0x0A68F}, {0x0A690, 0x0A691}, {0x0A692, 0x0A693}, {0x0A694, 0x0A695},
        {0x0A696, 0x0A697}, {0x0A698, 0x0A699}, {0x0A69A, 0x0A69B}, {0x0A722, 0x0A723},
        {0x0A724, 0x0A725}, {0x0A726, 0x0A727}, {0x0A728, 0x0A729}, {0x0A72A, 0x0A72B},
        {0x0A72C, 0x0A72D}, {0x0A72E, 0x0A72F}, {0x0A732, 0x0A733}, {0x0A734, 0x0A735},
        {0x0A736, 0x0A737}, {0x0A738, 0x0A739}, {0x0A73A, 0x0A73B}, {0x0A73C, 0x0A73D},
        {0x0A73E, 0x0A73F}, {0x0A740, 0x0A741}, {0x0A742, 0x0A743}, {0x0A744, 0x0A745},
        {0x0A746, 0x0A747}, {0x0A748, 0x0A749}, {0x0A74A, 0x0A74B}, {0x0A74C, 0x0A74D},
        {0x0A74E, 0x0A74F}, {0x0A750, 0x0A751}, {0x0A752, 0x0A753}, {0x0A754, 0x0A755},
        {0x0A756, 0x0A757}, {0x0A758, 0x0A759}, {0x0A75A, 0x0A75B}, {0x0A75C, 0x0A75D},
        {0x0A75E, 0x0A75F}, {0x0A760, 0x0A761}, {0x0A762, 0x0A763}, {0x0A764, 0x0A765},
        {0x0A766, 0x0A767}, {0x0A768, 0x0A769}, {0x0A76A, 0x0A76B}, {0x0A76C, 0x0A76D},
        {0x0A76E, 0x0A76F}, {0x0A779, 0x0A77A}, {0x0A77B, 0x0A77C}, {0x0A77D, 0x01D79},
        {0x0A77E, 0x0A77F}, {0x0A780, 0x0A781}, {0x0A782, 0x0A783}, {0x0A784, 0x0A785},
        {0x0A786, 0x0A787}, {0x0A78B, 0x0A78C}, {0x0A78D, 0x00265}, {0x0A790, 0x0A791},
        {0x0A792, 0x0A793}, {0x0A796, 0x0A797}, {0x0A798, 0x0A799}, {0x0A79A, 0x0A79B},
        {0x0A79C, 0x0A79D}, {0x0A79E, 0x0A79F}, {0x0A7A0, 0x0A7A1}, {0x0A7A2, 0x0A7A3},
        {0x0A7A4, 0x0A7A5}, {0x0A7A6, 0x0A7A7}, {0x0A7A8, 0x0A7A9}, {0x0A7AA, 0x00266},
        {0x0A7AB, 0x0025C}, {0x0A7AC, 0x00261}, {0x0A7AD, 0x0026C}, {0x0A7AE, 0x0026A},
        {0x0A7B0, 0x0029E}, {0x0A7B1, 0x00287}, {0x0A7B2, 0x0029D}, {0x0A7B3, 0x0AB53},
        {0x0A7B4, 0x0A7B5}, {0x0A7B6, 0x0A7B7}, {0x0AB70, 0x013A0}, {0x0AB71, 0x013A1},
        {0x0AB72, 0x013A2}, {0x0AB73, 0x013A3}, {0x0AB74, 0x013A4}, {0x0AB75, 0x013A5},
        {0x0AB76, 0x013A6}, {0x0AB77, 0x013A7}, {0x0AB78, 0x013A8}, {0x0AB79, 0x013A9},
        {0x0AB7A, 0x013AA}, {0x0AB7B, 0x013AB}, {0x0AB7C, 0x013AC}, {0x0AB7D, 0x013AD},
        {0x0AB7E, 0x013AE}, {0x0AB7F, 0x013AF}, {0x0AB80, 0x013B0}, {0x0AB81, 0x013B1},
        {0x0AB82, 0x013B2}, {0x0AB83, 0x013B3}, {0x0AB84, 0x013B4}, {0x0AB85, 0x013B5},
        {0x0AB86, 0x013B6}, {0x0AB87, 0x013B7}, {0x0AB88, 0x013B8}, {0x0AB89, 0x013B9},
        {0x0AB8A, 0x013BA}, {0x0AB8B, 0x013BB}, {0x0AB8C, 0x013BC}, {0x0AB8D, 0x013BD},
        {0x0AB8E, 0x013BE}, {0x0AB8F, 0x013BF}, {0x0AB90, 0x013C0}, {0x0AB91, 0x013C1},
        {0x0AB92, 0x013C2}, {0x0AB93, 0x013C3}, {0x0AB94, 0x013C4}, {0x0AB95, 0x013C5},
        {0x0AB96, 0x013C6}, {0x0AB97, 0x013C7}, {0x0AB98, 0x013C8}, {0x0AB99, 0x013C9},
        {0x0AB9A, 0x013CA}, {0x0AB9B, 0x013CB}, {0x0AB9C, 0x013CC}, {0x0AB9D, 0x013CD},
        {0x0AB9E, 0x013CE}, {0x0AB9F, 0x013CF}, {0x0ABA0, 0x013D0}, {0x0ABA1, 0x013D1},
        {0x0ABA2, 0x013D2}, {0x0ABA3, 0x013D3}, {0x0ABA4, 0x013D4}, {0x0ABA5, 0x013D5},
        {0x0ABA6, 0x013D6}, {0x0ABA7, 0x013D7}, {0x0ABA8, 0x013D8}, {0x0ABA9, 0x013D9},
        {0x0ABAA, 0x013DA}, {0x0ABAB, 0x013DB}, {0x0ABAC, 0x013DC}, {0x0ABAD, 0x013DD},
        {0x0ABAE, 0x013DE}, {0x0ABAF, 0x013DF}, {0x0ABB0, 0x013E0}, {0x0ABB1, 0x013E1},
        {0x0ABB2, 0x013E2}, {0x0ABB3, 0x013E3}, {0x0ABB4, 0x013E4}, {0x0ABB5, 0x013E5},
        {0x0ABB6, 0x013E6}, {0x0ABB7, 0x013E7}, {0x0ABB8, 0x013E8}, {0x0ABB9, 0x013E9},
        {0x0ABBA, 0x013EA}, {0x0ABBB, 0x013EB}, {0x0ABBC, 0x013EC}, {0x0ABBD, 0x013ED},
        {0x0ABBE, 0x013EE}, {0x0ABBF, 0x013EF}, {0x0FF21, 0x0FF41}, {0x0FF22, 0x0FF42},
        {0x0FF23, 0x0FF43}, {0x0FF24, 0x0FF44}, {0x0FF25, 0x0FF45}, {0x0FF26, 0x0FF46},
        {0x0FF27, 0x0FF47}, {0x0FF28, 0x0FF48}, {0x0FF29, 0x0FF49}, {0x0FF2A, 0x0FF4A},
        {0x0FF2B, 0x0FF4B}, {0x0FF2C, 0x0FF4C}, {0x0FF2D, 0x0FF4D}, {0x0FF2E, 0x0FF4E},
        {0x0FF2F, 0x0FF4F}, {0x0FF30, 0x0FF50}, {0x0FF31, 0x0FF51}, {0x0FF32, 0x0FF52},
        {0x0FF33, 0x0FF53}, {0x0FF34, 0x0FF54}, {0x0FF35, 0x0FF55}, {0x0FF36, 0x0FF56},
        {0x0FF37, 0x0FF57}, {0x0FF38, 0x0FF58}, {0x0FF39, 0x0FF59}, {0x0FF3A, 0x0FF5A},
        {0x10400, 0x10428}, {0x10401, 0x10429}, {0x10402, 0x1042A}, {0x10403, 0x1042B},
        {0x10404, 0x1042C}, {0x10405, 0x1042D}, {0x10406, 0x1042E}, {0x10407, 0x1042F},
        {0x10408, 0x10430}, {0x10409, 0x10431}, {0x1040A, 0x10432}, {0x1040B, 0x10433},
        {0x1040C, 0x10434}, {0x1040D, 0x10435}, {0x1040E, 0x10436}, {0x1040F, 0x10437},
        {0x10410, 0x10438}, {0x10411, 0x10439}, {0x10412, 0x1043A}, {0x10413, 0x1043B},
        {0x10414, 0x1043C}, {0x10415, 0x1043D}, {0x10416, 0x1043E}, {0x10417, 0x1043F},
        {0x10418, 0x10440}, {0x10419, 0x10441}, {0x1041A, 0x10442}, {0x1041B, 0x10443},
        {0x1041C, 0x10444}, {0x1041D, 0x10445}, {0x1041E, 0x10446}, {0x1041F, 0x10447},
        {0x10420, 0x10448}, {0x10421, 0x10449}, {0x10422, 0x1044A}, {0x10423, 0x1044B},
        {0x10424, 0x1044C}, {0x10425, 0x1044D}, {0x10426, 0x1044E}, {0x10427, 0x1044F},
        {0x104B0, 0x104D8}, {0x104B1, 0x104D9}, {0x104B2, 0x104DA}, {0x104B3, 0x104DB},
        {0x104B4, 0x104DC}, {0x104B5, 0x104DD}, {0x104B6, 0x104DE}, {0x104B7, 0x104DF},
        {0x104B8, 0x104E0}, {0x104B9, 0x104E1}, {0x104BA, 0x104E2}, {0x104BB, 0x104E3},
        {0x104BC, 0x104E4}, {0x104BD, 0x104E5}, {0x104BE, 0x104E6}, {0x104BF, 0x104E7},
        {0x104C0, 0x104E8}, {0x104C1, 0x104E9}, {0x104C2, 0x104EA}, {0x104C3, 0x104EB},
        {0x104C4, 0x104EC}, {0x104C5, 0x104ED}, {0x104C6, 0x104EE}, {0x104C7, 0x104EF},
        {0x104C8, 0x104F0}, {0x104C9, 0x104F1}, {0x104CA, 0x104F2}, {0x104CB, 0x104F3},
        {0x104CC, 0x104F4}, {0x104CD, 0x104F5}, {0x104CE, 0x104F6}, {0x104CF, 0x104F7},
        {0x104D0, 0x104F8}, {0x104D1, 0x104F9}, {0x104D2, 0x104FA}, {0x104D3, 0x104FB},
        {0x10C80, 0x10CC0}, {0x10C81, 0x10CC1}, {0x10C82, 0x10CC2}, {0x10C83, 0x10CC3},
        {0x10C84, 0x10CC4}, {0x10C85, 0x10CC5}, {0x10C86, 0x10CC6}, {0x10C87, 0x10CC7},
        {0x10C88, 0x10CC8}, {0x10C89, 0x10CC9}, {0x10C8A, 0x10CCA}, {0x10C8B, 0x10CCB},
        {0x10C8C, 0x10CCC}, {0x10C8D, 0x10CCD}, {0x10C8E, 0x10CCE}, {0x10C8F, 0x10CCF},
        {0x10C90, 0x10CD0}, {0x10C91, 0x10CD1}, {0x10C92, 0x10CD2}, {0x10C93, 0x10CD3},
        {0x10C94, 0x10CD4}, {0x10C95, 0x10CD5}, {0x10C96, 0x10CD6}, {0x10C97, 0x10CD7},
        {0x10C98, 0x10CD8}, {0x10C99, 0x10CD9}, {0x10C9A, 0x10CDA}, {0x10C9B, 0x10CDB},
        {0x10C9C, 0x10CDC}, {0x10C9D, 0x10CDD}, {0x10C9E, 0x10CDE}, {0x10C9F, 0x10CDF},
        {0x10CA0, 0x10CE0}, {0x10CA1, 0x10CE1}, {0x10CA2, 0x10CE2}, {0x10CA3, 0x10CE3},
        {0x10CA4, 0x10CE4}, {0x10CA5, 0x10CE5}, {0x10CA6, 0x10CE6}, {0x10CA7, 0x10CE7},
        {0x10CA8, 0x10CE8}, {0x10CA9, 0x10CE9}, {0x10CAA, 0x10CEA}, {0x10CAB, 0x10CEB},
        {0x10CAC, 0x10CEC}, {0x10CAD, 0x10CED}, {0x10CAE, 0x10CEE}, {0x10CAF, 0x10CEF},
        {0x10CB0, 0x10CF0}, {0x10CB1, 0x10CF1}, {0x10CB2, 0x10CF2}, {0x118A0, 0x118C0},
        {0x118A1, 0x118C1}, {0x118A2, 0x118C2}, {0x118A3, 0x118C3}, {0x118A4, 0x118C4},
        {0x118A5, 0x118C5}, {0x118A6, 0x118C6}, {0x118A7, 0x118C7}, {0x118A8, 0x118C8},
        {0x118A9, 0x118C9}, {0x118AA, 0x118CA}, {0x118AB, 0x118CB}, {0x118AC, 0x118CC},
        {0x118AD, 0x118CD}, {0x118AE, 0x118CE}, {0x118AF, 0x118CF}, {0x118B0, 0x118D0},
        {0x118B1, 0x118D1}, {0x118B2, 0x118D2}, {0x118B3, 0x118D3}, {0x118B4, 0x118D4},
        {0x118B5, 0x118D5}, {0x118B6, 0x118D6}, {0x118B7, 0x118D7}, {0x118B8, 0x118D8},
        {0x118B9, 0x118D9}, {0x118BA, 0x118DA}, {0x118BB, 0x118DB}, {0x118BC, 0x118DC},
        {0x118BD, 0x118DD}, {0x118BE, 0x118DE}, {0x118BF, 0x118DF}, {0x1E900, 0x1E922},
        {0x1E901, 0x1E923}, {0x1E902, 0x1E924}, {0x1E903, 0x1E925}, {0x1E904, 0x1E926},
        {0x1E905, 0x1E927}, {0x1E906, 0x1E928}, {0x1E907, 0x1E929}, {0x1E908, 0x1E92A},
        {0x1E909, 0x1E92B}, {0x1E90A, 0x1E92C}, {0x1E90B, 0x1E92D}, {0x1E90C, 0x1E92E},
        {0x1E90D, 0x1E92F}, {0x1E90E, 0x1E930}, {0x1E90F, 0x1E931}, {0x1E910, 0x1E932},
        {0x1E911, 0x1E933}, {0x1E912, 0x1E934}, {0x1E913, 0x1E935}, {0x1E914, 0x1E936},
        {0x1E915, 0x1E937}, {0x1E916, 0x1E938}, {0x1E917, 0x1E939}, {0x1E918, 0x1E93A},
        {0x1E919, 0x1E93B}, {0x1E91A, 0x1E93C}, {0x1E91B, 0x1E93D}, {0x1E91C, 0x1E93E},
        {0x1E91D, 0x1E93F}, {0x1E91E, 0x1E940}, {0x1E91F, 0x1E941}, {0x1E920, 0x1E942},
        {0x1E921, 0x1E943},
    };
    
    static const UTF32CodePoint UTF32DecimalNumbers[590][2] = {
        {0x00030,0}, {0x00031,1}, {0x00032,2}, {0x00033,3}, {0x00034,4}, {0x00035,5}, {0x00036,6}, {0x00037,7}, {0x00038,8}, {0x00039,9},
        {0x00660,0}, {0x00661,1}, {0x00662,2}, {0x00663,3}, {0x00664,4}, {0x00665,5}, {0x00666,6}, {0x00667,7}, {0x00668,8}, {0x00669,9},
        {0x006F0,0}, {0x006F1,1}, {0x006F2,2}, {0x006F3,3}, {0x006F4,4}, {0x006F5,5}, {0x006F6,6}, {0x006F7,7}, {0x006F8,8}, {0x006F9,9},
        {0x007C0,0}, {0x007C1,1}, {0x007C2,2}, {0x007C3,3}, {0x007C4,4}, {0x007C5,5}, {0x007C6,6}, {0x007C7,7}, {0x007C8,8}, {0x007C9,9},
        {0x00966,0}, {0x00967,1}, {0x00968,2}, {0x00969,3}, {0x0096A,4}, {0x0096B,5}, {0x0096C,6}, {0x0096D,7}, {0x0096E,8}, {0x0096F,9},
        {0x009E6,0}, {0x009E7,1}, {0x009E8,2}, {0x009E9,3}, {0x009EA,4}, {0x009EB,5}, {0x009EC,6}, {0x009ED,7}, {0x009EE,8}, {0x009EF,9},
        {0x00A66,0}, {0x00A67,1}, {0x00A68,2}, {0x00A69,3}, {0x00A6A,4}, {0x00A6B,5}, {0x00A6C,6}, {0x00A6D,7}, {0x00A6E,8}, {0x00A6F,9},
        {0x00AE6,0}, {0x00AE7,1}, {0x00AE8,2}, {0x00AE9,3}, {0x00AEA,4}, {0x00AEB,5}, {0x00AEC,6}, {0x00AED,7}, {0x00AEE,8}, {0x00AEF,9},
        {0x00B66,0}, {0x00B67,1}, {0x00B68,2}, {0x00B69,3}, {0x00B6A,4}, {0x00B6B,5}, {0x00B6C,6}, {0x00B6D,7}, {0x00B6E,8}, {0x00B6F,9},
        {0x00BE6,0}, {0x00BE7,1}, {0x00BE8,2}, {0x00BE9,3}, {0x00BEA,4}, {0x00BEB,5}, {0x00BEC,6}, {0x00BED,7}, {0x00BEE,8}, {0x00BEF,9},
        {0x00C66,0}, {0x00C67,1}, {0x00C68,2}, {0x00C69,3}, {0x00C6A,4}, {0x00C6B,5}, {0x00C6C,6}, {0x00B6D,7}, {0x00C6E,8}, {0x00C6F,9},
        {0x00CE6,0}, {0x00CE7,1}, {0x00CE8,2}, {0x00CE9,3}, {0x00CEA,4}, {0x00CEB,5}, {0x00CEC,6}, {0x00CED,7}, {0x00CEE,8}, {0x00CEF,9},
        {0x00D66,0}, {0x00D67,1}, {0x00D68,2}, {0x00D69,3}, {0x00D6A,4}, {0x00D6B,5}, {0x00D6C,6}, {0x00D6D,7}, {0x00D6E,8}, {0x00D6F,9},
        {0x00DE6,0}, {0x00DE7,1}, {0x00DE8,2}, {0x00DE9,3}, {0x00DEA,4}, {0x00DEB,5}, {0x00DEC,6}, {0x00DED,7}, {0x00DEE,8}, {0x00DEF,9},
        {0x00E50,0}, {0x00E51,1}, {0x00E52,2}, {0x00E53,3}, {0x00E54,4}, {0x00E55,5}, {0x00E56,6}, {0x00E57,7}, {0x00E58,8}, {0x00E59,9},
        {0x00ED0,0}, {0x00ED1,1}, {0x00ED2,2}, {0x00ED3,3}, {0x00ED4,4}, {0x00ED5,5}, {0x00ED6,6}, {0x00ED7,7}, {0x00ED8,8}, {0x00ED9,9},
        {0x00F20,0}, {0x00F21,1}, {0x00F22,2}, {0x00F23,3}, {0x00F24,4}, {0x00F25,5}, {0x00F26,6}, {0x00F27,7}, {0x00F28,8}, {0x00F29,9},
        {0x01040,0}, {0x01041,1}, {0x01042,2}, {0x01043,3}, {0x01044,4}, {0x01045,5}, {0x01046,6}, {0x01047,7}, {0x01048,8}, {0x01049,9},
        {0x01090,0}, {0x01091,1}, {0x01092,2}, {0x01093,3}, {0x01094,4}, {0x01095,5}, {0x01096,6}, {0x01097,7}, {0x01098,8}, {0x01099,9},
        {0x017E0,0}, {0x017E1,1}, {0x017E2,2}, {0x017E3,3}, {0x017E4,4}, {0x017E5,5}, {0x017E6,6}, {0x017E7,7}, {0x017E8,8}, {0x017E9,9},
        {0x01810,0}, {0x01811,1}, {0x01812,2}, {0x01813,3}, {0x01814,4}, {0x01815,5}, {0x01816,6}, {0x01817,7}, {0x01818,8}, {0x01819,9},
        {0x01946,0}, {0x01947,1}, {0x01948,2}, {0x01949,3}, {0x0194A,4}, {0x0194B,5}, {0x0194C,6}, {0x0194D,7}, {0x0194D,8}, {0x0194F,9},
        {0x019D0,0}, {0x019D1,1}, {0x019D2,2}, {0x019D3,3}, {0x019D4,4}, {0x019D5,5}, {0x019D6,6}, {0x019D7,7}, {0x019D8,8}, {0x019D9,9},
        {0x01A80,0}, {0x01A81,1}, {0x01A82,2}, {0x01A83,3}, {0x01A84,4}, {0x01A85,5}, {0x01A86,6}, {0x01A87,7}, {0x01A88,8}, {0x01A89,9},
        {0x01A90,0}, {0x01A91,1}, {0x01A92,2}, {0x01A93,3}, {0x01A94,4}, {0x01A95,5}, {0x01A96,6}, {0x01A97,7}, {0x01A98,8}, {0x01A99,9},
        {0x01B50,0}, {0x01B51,1}, {0x01B52,2}, {0x01B53,3}, {0x01B54,4}, {0x01B55,5}, {0x01B56,6}, {0x01B57,7}, {0x01B58,8}, {0x01B59,9},
        {0x01BB0,0}, {0x01BB1,1}, {0x01BB2,2}, {0x01BB3,3}, {0x01BB4,4}, {0x01BB5,5}, {0x01BB6,6}, {0x01BB7,7}, {0x01BB8,8}, {0x01BB9,9},
        {0x01C40,0}, {0x01C41,1}, {0x01C42,2}, {0x01C43,3}, {0x01C44,4}, {0x01C45,5}, {0x01C46,6}, {0x01C47,7}, {0x01C48,8}, {0x01C49,9},
        {0x01C50,0}, {0x01C51,1}, {0x01C52,2}, {0x01C53,3}, {0x01C54,4}, {0x01C55,5}, {0x01C56,6}, {0x01C57,7}, {0x01C58,8}, {0x01C59,9},
        {0x0A620,0}, {0x0A621,1}, {0x0A622,2}, {0x0A623,3}, {0x0A624,4}, {0x0A625,5}, {0x0A626,6}, {0x0A627,7}, {0x0A628,8}, {0x0A629,9},
        {0x0A8D0,0}, {0x0A8D1,1}, {0x0A8D2,2}, {0x0A8D3,3}, {0x0A8D4,4}, {0x0A8D5,5}, {0x0A8D6,6}, {0x0A8D7,7}, {0x0A8D8,8}, {0x0A8D9,9},
        {0x0A900,0}, {0x0A901,1}, {0x0A902,2}, {0x0A903,3}, {0x0A904,4}, {0x0A905,5}, {0x0A906,6}, {0x0A907,7}, {0x0A908,8}, {0x0A909,9},
        {0x0A9D0,0}, {0x0A9D1,1}, {0x0A9D2,2}, {0x0A9D3,3}, {0x0A9D4,4}, {0x0A9D5,5}, {0x0A9D6,6}, {0x0A9D7,7}, {0x0A9D8,8}, {0x0A9D9,9},
        {0x0A9F0,0}, {0x0A9F1,1}, {0x0A9F2,2}, {0x0A9F3,3}, {0x0A9F4,4}, {0x0A9F5,5}, {0x0A9F6,6}, {0x0A9F7,7}, {0x0A9F8,8}, {0x0A9F9,9},
        {0x0AA50,0}, {0x0AA51,1}, {0x0AA52,2}, {0x0AA53,3}, {0x0AA54,4}, {0x0AA55,5}, {0x0AA56,6}, {0x0AA57,7}, {0x0AA58,8}, {0x0AA59,9},
        {0x0ABF0,0}, {0x0ABF1,1}, {0x0ABF2,2}, {0x0ABF3,3}, {0x0ABF4,4}, {0x0ABF5,5}, {0x0ABF6,6}, {0x0ABF7,7}, {0x0ABF8,8}, {0x0ABF9,9},
        {0x0FF10,0}, {0x0FF11,1}, {0x0FF12,2}, {0x0FF13,3}, {0x0FF14,4}, {0x0FF15,5}, {0x0FF16,6}, {0x0FF17,7}, {0x0FF18,8}, {0x0FF19,9},
        {0x104A0,0}, {0x104A1,1}, {0x104A2,2}, {0x104A3,3}, {0x104A4,4}, {0x104A5,5}, {0x104A6,6}, {0x104A7,7}, {0x104A8,8}, {0x104A9,9},
        {0x11066,0}, {0x11067,1}, {0x11068,2}, {0x11069,3}, {0x1106A,4}, {0x1106B,5}, {0x1106C,6}, {0x1106D,7}, {0x1106E,8}, {0x1106F,9},
        {0x110F0,0}, {0x110F1,1}, {0x110F2,2}, {0x110F3,3}, {0x110F4,4}, {0x110F5,5}, {0x110F6,6}, {0x110F7,7}, {0x110F8,8}, {0x110F9,9},
        {0x11136,0}, {0x11137,1}, {0x11138,2}, {0x11139,3}, {0x1113A,4}, {0x1113B,5}, {0x1113C,6}, {0x1113D,7}, {0x1113E,8}, {0x1113F,9},
        {0x111D0,0}, {0x111D1,1}, {0x111D2,2}, {0x111D3,3}, {0x111D4,4}, {0x111D5,5}, {0x111D6,6}, {0x111D7,7}, {0x111D8,8}, {0x111D9,9},
        {0x112F0,0}, {0x112F1,1}, {0x112F2,2}, {0x112F3,3}, {0x112F4,4}, {0x112F5,5}, {0x112F6,6}, {0x112F7,7}, {0x112F8,8}, {0x112F9,9},
        {0x11450,0}, {0x11451,1}, {0x11452,2}, {0x11453,3}, {0x11454,4}, {0x11455,5}, {0x11456,6}, {0x11457,7}, {0x11458,8}, {0x11459,9},
        {0x114D0,0}, {0x114D1,1}, {0x114D2,2}, {0x114D3,3}, {0x114D4,4}, {0x114D5,5}, {0x114D6,6}, {0x114D7,7}, {0x114D8,8}, {0x114D9,9},
        {0x11650,0}, {0x11651,1}, {0x11652,2}, {0x11653,3}, {0x11654,4}, {0x11655,5}, {0x11656,6}, {0x11657,7}, {0x11658,8}, {0x11659,9},
        {0x116C0,0}, {0x116C1,1}, {0x116C2,2}, {0x116C3,3}, {0x116C4,4}, {0x116C5,5}, {0x116C6,6}, {0x116C7,7}, {0x116C8,8}, {0x116C9,9},
        {0x11730,0}, {0x11731,1}, {0x11732,2}, {0x11733,3}, {0x11734,4}, {0x11735,5}, {0x11736,6}, {0x11737,7}, {0x11738,8}, {0x11739,9},
        {0x118E0,0}, {0x118E1,1}, {0x118E2,2}, {0x118E3,3}, {0x118E4,4}, {0x118E5,5}, {0x118E6,6}, {0x118E7,7}, {0x118E8,8}, {0x118E9,9},
        {0x11C50,0}, {0x11C51,1}, {0x11C52,2}, {0x11C53,3}, {0x11C54,4}, {0x11C55,5}, {0x11C56,6}, {0x11C57,7}, {0x11C58,8}, {0x11C59,9},
        {0x11D50,0}, {0x11D51,1}, {0x11D52,2}, {0x11D53,3}, {0x11D54,4}, {0x11D55,5}, {0x11D56,6}, {0x11D57,7}, {0x11D58,8}, {0x11D59,9},
        {0x16A60,0}, {0x16A61,1}, {0x16A62,2}, {0x16A63,3}, {0x16A64,4}, {0x16A65,5}, {0x16A66,6}, {0x16A67,7}, {0x16A68,8}, {0x16A69,9},
        {0x16B50,0}, {0x16B51,1}, {0x16B52,2}, {0x16B53,3}, {0x16B54,4}, {0x16B55,5}, {0x16B56,6}, {0x16B57,7}, {0x16B58,8}, {0x16B59,9},
        {0x1D7CE,0}, {0x1D7CF,1}, {0x1D7D0,2}, {0x1D7D1,3}, {0x1D7D2,4}, {0x1D7D3,5}, {0x1D7D4,6}, {0x1D7D5,7}, {0x1D7D6,8}, {0x1D7D7,9},
        {0x1D7D8,0}, {0x1D7D9,1}, {0x1D7DA,2}, {0x1D7DB,3}, {0x1D7DC,4}, {0x1D7DD,5}, {0x1D7DE,6}, {0x1D7DF,7}, {0x1D7E0,8}, {0x1D7E1,9},
        {0x1D7E2,0}, {0x1D7E3,1}, {0x1D7E4,2}, {0x1D7E5,3}, {0x1D7E6,4}, {0x1D7E7,5}, {0x1D7E8,6}, {0x1D7E9,7}, {0x1D7EA,8}, {0x1D8EB,9},
        {0x1D7EC,0}, {0x1D7ED,1}, {0x1D7EE,2}, {0x1D7EF,3}, {0x1D7F0,4}, {0x1D7F1,5}, {0x1D7F2,6}, {0x1D7F3,7}, {0x1D7F4,8}, {0x1D7F5,9},
        {0x1D7F6,0}, {0x1D7F7,1}, {0x1D7F8,2}, {0x1DC79,3}, {0x1D7FA,4}, {0x1D7FB,5}, {0x1D7FC,6}, {0x1D7FD,7}, {0x1D7FE,8}, {0x1D7FF,9},
        {0x1E950,0}, {0x1E951,1}, {0x1E952,2}, {0x1E953,3}, {0x1E954,4}, {0x1E955,5}, {0x1E956,6}, {0x1E957,7}, {0x1E958,8}, {0x1E959,9},
    };
    
    void UTF32String_Normalize(UTF32String String2Normalize) {
        /*
         So we should try to convert codepoints to a precomposed codepoint, but if we can't we need to order them by their lexiographic value.
         */
        uint64_t CodePoint    = 1ULL; // Skip the BOM
        if (String2Normalize != NULL) {
            do {
                // For each codepoint, compare it to the base number, if it matches one, then compare the following codepoint(s) to the diacritic(s), if they all match, replace.
                /*
                for (uint8_t TableColumn = 0; TableColumn < NormalizationTableIndex; TableColumn++) {
                    for (uint8_t Diacritic = NormalizationTable[]; Diacritic < NormalizationTable[TableColumn][0]; Diacritic++) {
                        
                    }
                }
                 */
            } while (String2Normalize[CodePoint] != 0);
        } else {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String2Normalize Pointer is NULL");
        }
    }

    void            UTF32String_CaseFold(UTF32String String) {
        uint64_t CodePoint = 1ULL;
        if (String != NULL) {
            do {
                for (uint16_t Table = 0; Table < SimpleCaseFoldTableSize; Table++) {
                    if (String[CodePoint] == SimpleCaseFoldTable[Table][0]) {
                        String[CodePoint]  = SimpleCaseFoldTable[Table][1];
                    }
                }
            } while (String[CodePoint] != 0);
        } else {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL");
        }
    }
    
    static uint64_t UTF32String_GetNumCodePoints(UTF32String String) {
        uint64_t NumCodePoints          = 0;
        do {
            NumCodePoints              += 1;
        } while (String[NumCodePoints] != 0);
        return NumCodePoints;
    }
    
    bool            UTF32Strings_Compare(UTF32String String1, UTF32String String2) {
        uint64_t CodePoint = 0ULL;
        bool StringsMatch  = Yes;
        if (String1 != NULL && String2 != NULL) {
            uint64_t String1Size = UTF32String_GetNumCodePoints(String1);
            uint64_t String2Size = UTF32String_GetNumCodePoints(String2);
            if (String1Size != String2Size) {
                StringsMatch = No;
            } else {
                do {
                    if (String1[CodePoint] != String2[CodePoint]) {
                        StringsMatch = No;
                        break;
                    }
                } while (String1[CodePoint] != 0 && String2[CodePoint] != 0);
            }
        } else if (String1 == NULL) {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String1 Pointer is NULL");
        } else if (String2 == NULL) {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String2 Pointer is NULL");
        }
        return StringsMatch;
    }
    
    uint64_t        UTF32String_FindSubstring(UTF32String String, UTF32String SubString) {
        uint64_t   Offset             = 0ULL;
        uint64_t   CodePoint          = 1ULL;
        uint64_t   SubStringCodePoint = 1ULL;
        if (String != NULL && SubString != NULL) {
            do {
                if (String[CodePoint] == SubString[SubStringCodePoint] && String[CodePoint] == SubString[SubStringCodePoint]) {
                    // Ok well lets go ahead and implement finding substring
                }
            } while (String[CodePoint] != 0);
        } else if (String == NULL) {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL");
        } else if (SubString == NULL) {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"SubString Pointer is NULL");
        }
        return Offset;
    }
    
    UTF32String         UTF32String_Extract(UTF32String String, uint64_t Start, uint64_t End) {
        uint64_t    ExtractedStringSize = (Start - End) + 1 + UnicodeNULLTerminatorSize;
        UTF32String ExtractedString     = NULL;
        if (String != NULL && End > Start) {
            ExtractedString             = calloc(ExtractedStringSize, sizeof(uint32_t));
            if (ExtractedString != NULL) {
                for (uint64_t CodePoint = Start; CodePoint < End; CodePoint++) {
                    ExtractedString[CodePoint - Start] = String[CodePoint];
                }
            } else {
                BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"Not enough memory to allocate ExtractedString");
            }
        } else if (String == NULL) {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"String Pointer is NULL");
        } else if (End < Start) {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, u8"End is before Start");
        }
        return ExtractedString;
    }
    
    int64_t             UTF32String_ToNumber(UTF32String String) {
        uint64_t CodePoint  = 0ULL;
        int8_t   Sign       =  1;
        uint8_t  Base       = 10;
        int64_t  Value      =  0;
        for (uint8_t WhiteSpace = 0; WhiteSpace < WhitespaceTableSize; WhiteSpace++) {
            if (String[CodePoint] == WhitespaceTable[WhiteSpace]) {
                CodePoint += 1;
            }
        }
        if (String[CodePoint] == '0') {
            if (String[CodePoint + 1] == 'b' || String[CodePoint + 1] == 'B') {
                Base = 2;
            } else if (String[CodePoint + 1] == 'o' || String[CodePoint] == 'O') {
                Base = 8;
            } else if (String[CodePoint + 1] == 'x' || String[CodePoint] == 'X') {
                Base = 16;
            }
        } else if (String[CodePoint] == '-') {
            Sign     = -1;
        }
        do {
            Value     *= Base;
            if (Base == 16 && (String[CodePoint] >= 0x41 && String[CodePoint] <= 0x46)) {
                Value += (String[CodePoint] - 50);
            } else if (Base == 16 && (String[CodePoint] >= 0x61 && String[CodePoint] <= 0x66)) {
                Value += (String[CodePoint] - 82);
            } else if ((Base == 10 || Base == 16) && (String[CodePoint] >= 0x30 && String[CodePoint] <= 0x39)) {
                Value += (String[CodePoint] - 48);
            } else if (Base == 8 && (String[CodePoint] >= 0x30 && String[CodePoint] <= 0x37)) {
                Value += (String[CodePoint] - 48);
            } else if (Base == 2 && (String[CodePoint] >= 0x30 && String[CodePoint] <= 0x31)) {
                Value += (String[CodePoint] - 48);
            }
        } while (String[CodePoint] != 0);
        return Sign < 0 ? Value * Sign : Value;
    }
    
    bool                UTF8String_Compare(UTF8String String1, UTF8String String2, bool Normalize, bool CaseFold) {
        bool StringsMatch = No;
        if (String1 != NULL && String2 != NULL) {
            UTF32String String1UTF32 = UTF8String_Decode(String1);
            UTF32String String2UTF32 = UTF8String_Decode(String2);
            if (Normalize == Yes) {
                UTF32String_Normalize(String1UTF32);
                UTF32String_Normalize(String2UTF32);
            }
            if (CaseFold == Yes) {
                UTF32String_CaseFold(String1UTF32);
                UTF32String_CaseFold(String2UTF32);
            }
            StringsMatch = UTF32Strings_Compare(String1UTF32, String2UTF32);
            free(String1UTF32);
            free(String2UTF32);
        } else if (String1 == NULL) {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, "String1 Pointer is NULL");
        } else if (String2 == NULL) {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, "String2 Pointer is NULL");
        }
        return StringsMatch;
    }
    
    bool               UTF16String_Compare(UTF16String String1, UTF16String String2, bool Normalize, bool CaseFold) {
        bool StringsMatch = No;
        if (String1 != NULL && String2 != NULL) {
            UTF32String String1UTF32 = UTF16String_Decode(String1);
            UTF32String String2UTF32 = UTF16String_Decode(String2);
            if (Normalize == Yes) {
                UTF32String_Normalize(String1UTF32);
                UTF32String_Normalize(String2UTF32);
            }
            if (CaseFold == Yes) {
                UTF32String_CaseFold(String1UTF32);
                UTF32String_CaseFold(String2UTF32);
            }
            StringsMatch = UTF32Strings_Compare(String1UTF32, String2UTF32);
        } else if (String1 == NULL) {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, "String1 Pointer is NULL");
        } else if (String2 == NULL) {
            BitIOLog(BitIOLog_ERROR, StringIOLibraryName, __func__, "String2 Pointer is NULL");
        }
        return StringsMatch;
    }
    
#ifdef  __cplusplus
}
#endif
